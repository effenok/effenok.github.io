<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Spanning Trees: Basic Tree | Network89</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Spanning Trees: Basic Tree" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Spanning Trees:" />
<meta property="og:description" content="Spanning Trees:" />
<link rel="canonical" href="http://localhost:4000/spanning-tree/2021/10/29/spanning-tree-2.html" />
<meta property="og:url" content="http://localhost:4000/spanning-tree/2021/10/29/spanning-tree-2.html" />
<meta property="og:site_name" content="Network89" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-29T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Spanning Trees: Basic Tree" />
<script type="application/ld+json">
{"description":"Spanning Trees:","@type":"BlogPosting","headline":"Spanning Trees: Basic Tree","dateModified":"2021-10-29T00:00:00+00:00","datePublished":"2021-10-29T00:00:00+00:00","url":"http://localhost:4000/spanning-tree/2021/10/29/spanning-tree-2.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/spanning-tree/2021/10/29/spanning-tree-2.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Network89" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Network89</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/networking/">Networking</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Spanning Trees: Basic Tree</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-10-29T00:00:00+00:00" itemprop="datePublished">Oct 29, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Spanning Trees:</p>
<ul>


 
<li><a href="/spanning-tree/2021/10/29/spanning-tree-1.html">Spanning Trees: Introduction</a></li>

 
<li>Spanning Trees: Basic Tree</li>

 
<li><a href="/spanning-tree/2021/10/29/spanning-tree-3.html">Spanning Trees: Breadth-First-Search Tree</a></li>


</ul>

<h2 id="basic-tree">Basic Tree</h2>

<p>The first algorithm constructs <em>any</em> spanning tree, rooted at a pre-defined node. This is a very simple algorithm. Root
node sends a special message, let’s call it <code class="language-plaintext highlighter-rouge">build-tree</code> to all its neighbors. Each neighbor receives the message, sets
its parent node to the sender of the message and then sends its own <code class="language-plaintext highlighter-rouge">build-tree</code> message to all of its neighbors except
for the parent. Note, that nodes (ehm, i mean processes) can receive multiple <code class="language-plaintext highlighter-rouge">build-tree</code> messages. In the simple
algorithm, each node selects the sender of the first received  <code class="language-plaintext highlighter-rouge">build-tree</code> message to be its parent.</p>

<p>Let’s define the algorithm more formally. First, each node has a unique identifier. Second, each node wants to know the
current root. Well, let’s assume that it needs to, although it is not strictly necessary for this algorithm. Third, each
node saves its parent node. The root node starts with root equal to itself, and null parent. This will never change. All
other nodes do not know the values of either root or parent, thus they start with these values being null and fill them
later.</p>

<p>Nodes exchange the <code class="language-plaintext highlighter-rouge">build-tree</code>
message. This message needs to carry the id of the root node.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Basic spanning tree algorithm

variables = { 
    uid: &lt;random unique id&gt;, 
    parent: uid or null, initially null, 
    root: uid or null, initially node's id for root node and null for other nodes
}

messages = build-tree {root: uid}

start: 
    if /* node is root */ self.root != null
        send build-tree to all neighbors

on receive build-tree {root} from neighbor j
    if self.parent == null
        self.parent = j
        self.root = build-tree.root
        send build-tree to all neighbors except j
</code></pre></div></div>

<p>Ok, too much text, but here is a simple spanning tree. What have we achieved, and what not?</p>

<ul>
  <li><strong>achieved</strong>
    <ul>
      <li>construct a spanning tree, where each node knows its parent</li>
    </ul>
  </li>
  <li><strong>not achieved</strong>
    <ul>
      <li>tree is not a shortest path tree or anything, it can be suboptimal.</li>
      <li>tree is arbitrary, and there is no control on the structure of the tree</li>
    </ul>
  </li>
</ul>

<p class="notification">One thing to note about this algorithm, is that each node knows when it achieves a quiescence state.
Informally, quiescence state is a state in which internal state of the node does not change. Here it means that each
node knows when the construction of the tree has stabilized. Yes, it is trivial here, but this is something that is not
that trivial when constructing trees based on distance.</p>

<ul>
  <li><strong>achieved</strong>
    <ul>
      <li>each node knows when the tree is stable</li>
    </ul>
  </li>
</ul>

<div class="container has-text-centered">
<p> resulting spanning tree</p>
<img src="/assets/images/spanning-trees/images.dot.2.png" alt="distributed system" />
</div>

<h3 id="for-state-machine-lovers">For state machine lovers</h3>

<p>If you like state machines, I can also define states and variables that make sense in these states. Although these
states will not make much sense in the next two algorithms below. So, root can have a special state <code class="language-plaintext highlighter-rouge">root</code>. For each
other node something happens for the first received <code class="language-plaintext highlighter-rouge">build-tree</code> message. Let’s define two states - <code class="language-plaintext highlighter-rouge">unmarked</code> and
<code class="language-plaintext highlighter-rouge">marked</code>, for nodes that have not yet received or have already received their first <code class="language-plaintext highlighter-rouge">build-tree</code> message. Since there
are states, i will attach state variables to states. This can be done in Rust.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Basic spanning tree algorithm with states

states = {root, unmarked, marked }

variables = { 
    uid: &lt;random unique id&gt;, 
    
    in state marked {
        root: uid of root node
        parent: uid of parent node
    }
}

messages = build-tree {root: uid}

start: 
    if in state root: 
        send build-tree to all neighbors

on receving build-tree {root} from neighbor j
    if in state unmarked
        self.parent = j
        self.root = build-tree.root
        send build-tree to all neighbors except j
    else 
        ignore the message
</code></pre></div></div>

  </div><a class="u-url" href="/spanning-tree/2021/10/29/spanning-tree-2.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Network89</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Network89</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/effenok"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">effenok</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>hey. welcome to my blog where i try to share some random rumbling about networking</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
